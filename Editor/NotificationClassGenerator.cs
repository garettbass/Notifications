using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Object = UnityEngine.Object;

public static class NotificationClassGenerator
{

    public const int MenuPriority = 0;

    [InitializeOnLoadMethod]
    private static void InitializeOnLoad()
    {
        GenerateNotificationClasses(
            logThresholdMs: 64,
            skipCoreNotificationClasses: true);
    }

    [MenuItem(
        "Assets/Create/Notification/Generate Notification Classes",
        priority = MenuPriority + 128)]
    private static void GenerateNotificationClassesMenuItem()
    {
        GenerateNotificationClasses(
            logThresholdMs: 0,
            skipCoreNotificationClasses: false);
    }

    private static void GenerateNotificationClasses(
        double logThresholdMs = 0,
        bool skipCoreNotificationClasses = false)
    {
        var start = DateTime.Now;
        GenerateCoreNotificationClasses();
        GenerateNotificationMessageAttributedClasses();
        var elapsedMs = (DateTime.Now - start).TotalMilliseconds;
        if (elapsedMs > logThresholdMs)
            Debug.Log($"GenerateNotificationClasses() took {elapsedMs} ms.");
    }

    private static void GenerateCoreNotificationClasses()
    {
        var filePath =
            new StackTrace(fNeedFileInfo: true)
            .GetFrame(0)
            .GetFileName();
        var editorDirectory =
            Path.GetDirectoryName(filePath);
        var notificationsDirectory =
            Path.GetDirectoryName(editorDirectory);
        var generatedDirectory =
            Path.Combine(notificationsDirectory, "Generated");
        GenerateNotificationClasses<Color>(generatedDirectory);
        GenerateNotificationClasses<float>(generatedDirectory, "Float");
        GenerateNotificationClasses<GameObject>(generatedDirectory);
        GenerateNotificationClasses<int>(generatedDirectory, "Integer");
        GenerateNotificationClasses<Object>(generatedDirectory);
        GenerateNotificationClasses<RaycastHit>(generatedDirectory);
        GenerateNotificationClasses<Sprite>(generatedDirectory);
        GenerateNotificationClasses<string>(generatedDirectory);
        GenerateNotificationClasses<Transform>(generatedDirectory);
        GenerateNotificationClasses<Vector2>(generatedDirectory);
        GenerateNotificationClasses<Vector3>(generatedDirectory);
        GenerateNotificationClasses<Vector4>(generatedDirectory);
    }

    public static void GenerateNotificationMessageAttributedClasses()
    {
        var notificationMessageAttributes =
            NotificationMessageAttribute.FindAll();

        foreach (var attribute in notificationMessageAttributes)
            GenerateNotificationClasses(
                attribute.notificationClassDirectory,
                attribute.notificationMessageType);
    }

    public static void GenerateNotificationClasses<T>(
        string directory,
        string messageName = null)
    {
        GenerateNotificationClasses(directory, typeof(T), messageName);
    }

    public static void GenerateNotificationClasses(
        string directory,
        Type messageType,
        string messageName = null)
    {
        var assetsRoot = "Assets/";
        if (directory.StartsWith(assetsRoot))
            directory = directory.Substring(assetsRoot.Length);
        var dataPath = Application.dataPath;
        if (directory.StartsWith(dataPath) == false)
            directory = Path.Combine(dataPath, directory);
        if (Directory.Exists(directory) == false)
            Directory.CreateDirectory(directory);

        if (messageName == null)
            messageName = messageType.Name;

        Debug.Log($"generate {directory}/{messageName}...");
        GenerateNotification(directory, messageType, messageName);
        GenerateNotificationEvent(directory, messageType, messageName);
        GenerateNotificationReceiver(directory, messageType, messageName);
    }

    private static void GenerateNotification(
        string directory,
        Type messageType,
        string messageName)
    {
        var fullName = messageType.FullName;
        var fileName = $"{messageName}Notification.cs";
        var filePath = Path.Combine(directory, fileName);
        if (File.Exists(filePath))
            return;

        var order = MenuPriority + (int)messageName[0];
        var source =
            $"// Generated by NotificationClassGenerator\n" +
            $"[UnityEngine.CreateAssetMenu(\n" +
            $"    menuName =\"Notification/{messageName} Notification\",\n"+
            $"    order = {order})]\n" +
            $"public class {messageName}Notification :\n" +
            $"    Notification<{fullName}>\n" +
            $"{{ }}";

        File.WriteAllText(filePath, source);
        ImportFileOnNextEditorUpdate(filePath);
    }

    private static void GenerateNotificationEvent(
        string directory,
        Type messageType,
        string messageName)
    {
        var fullName = messageType.FullName;
        var fileName = $"{messageName}NotificationEvent.cs";
        var filePath = Path.Combine(directory, fileName);
        if (File.Exists(filePath))
            return;

        var source =
            $"// Generated by NotificationClassGenerator\n" +
            $"[System.Serializable]\n" +
            $"public class {messageName}NotificationEvent :\n" +
            $"    NotificationEvent<{fullName}>\n" +
            $"{{ }}";

        File.WriteAllText(filePath, source);
        ImportFileOnNextEditorUpdate(filePath);
    }

    private static void GenerateNotificationReceiver(
        string directory,
        Type messageType,
        string messageName)
    {
        var fullName = messageType.FullName;
        var fileName = $"{messageName}NotificationReceiver.cs";
        var filePath = Path.Combine(directory, fileName);
        if (File.Exists(filePath))
            return;

        var source =
            $"// Generated by NotificationClassGenerator\n" +
            $"public class {messageName}NotificationReceiver :\n" +
            $"    NotificationReceiver<\n" +
            $"        {fullName},\n" +
            $"        {messageName}Notification,\n" +
            $"        {messageName}NotificationEvent>\n" +
            $"{{ }}";

        File.WriteAllText(filePath, source);
        ImportFileOnNextEditorUpdate(filePath);
    }

    private static readonly HashSet<string>
    s_filesToImport = new HashSet<string>();

    private static void ImportFileOnNextEditorUpdate(string fileToImport)
    {
        Debug.Log($"generated {fileToImport}");
        s_filesToImport.Add(fileToImport);
        EditorApplication.delayCall -= ImportFiles;
        EditorApplication.delayCall += ImportFiles;
    }

    private static void ImportFiles()
    {
        var filesToImport = s_filesToImport.ToArray();
        s_filesToImport.Clear();
        if (filesToImport.Length > 0)
        {
            foreach (var fileToImport in filesToImport)
                AssetDatabase.ImportAsset(fileToImport);
            AssetDatabase.Refresh();
        }
    }

}